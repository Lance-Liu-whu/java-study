## 思路:

1.每个程序都有入口点(OEP),首先要找到OEP ,让原来执行OEP的第一条语句改为执行我们自定义的代码.

在执行完自定义代码后再继续执行OEP的代码.等同于在OEP前面先调用我们的代码



## 操作:

### 1.找到入口点(OEP) 

![1661780618817](../img/ODImg/1661780618817.png)

​		从图上可知, 偏移是ImageBase字段=`400000 `,入口点地址为`183D7` 。所以加上偏移的地址为`4183d7`

### 2.研究call, jmp指令硬编码

![1661780836929](../img/ODImg/1661780836929.png)

因为我们知道要实现先调用我们的代码. 要用到`call`指令.

调用完成后.要跳到OEP的地址,还需要用到`JMP`指令.

我们先看`call`指令硬编码.

通过红色方框可知 ,当前的地址是 `0x010d140E` ,最右边的注释是调用函数`function(10D119A)`,真实的硬编码是

`E8 87 FD FF FF` ，其中`E8`是`call`指令关键词,即硬编码地址是：`87 FD FF FF`

其实调用函数`function(10D119A)`与当前的地址 `0x010d140E`和硬编码的关系是:

```
公式1:
真实的地址=E8的地址下一行(绿色方框) + X(硬编码)

带入公式：
10D119A=10D1413+FFFFFD87（小端存储，要反过来）
```

如果我们要知道 `X(硬编码)的值`,可以将等式转换一下:

```
公式2:
X(硬编码)=真实的地址 - E8的地址下一行(绿色方框)  

带入公式：
硬编码 = 10D119A - 10D1413
```

同时:

红色方框`0x010d140E`与绿色方框`0x010d1413`之间的关系是

**绿色方框的地址 =  红色方框的地址+硬编码对应的字节数 =`0x010d140E` + `5` **

即公式2变形:

```
X(硬编码)=真实的地址 - ( E8的地址+5 )

带入公式：
硬编码 = 10D119A - （10d140E + 5 ）  = 10D119A - 10d140E - 5
```



### 3.找到MessageBoxA硬编码

#### 1.使用OD 下一个 bp MessageBoxA的断点

![1661776227580](../img/ODImg/1661776227580.png)

此时在我的机器上调用`MessageBox`的硬编码为`0x77D507EA`

#### 2.在正向代码中查看调用MessageBox参数

```c++
#include "stdafx.h"
#include <windows.h> 

void function () {
	MessageBox(0,0,0,0);
}


int _tmain(int argc, _TCHAR* argv[])
{
	function();
	return 0;
}


```

​																	正向代码





```
00D713C0 6A 00                push        0  
00D713C2 6A 00                push        0  
00D713C4 6A 00                push        0  
00D713C6 6A 00                push        0  
00D713C8 FF 15 38 83 D7 00    call        dword ptr [__imp__MessageBoxW@16 (0D78338h)]  
```

​																		汇编代码



通过汇编代码可知,参数的4个参数0,都是以硬编码`6A 00`传入的





### 4.找到飞鸽传书代码区

#### 1.使用ultraEdit打开飞鸽传书

#### 2.查看PE

![1661781900869](../img/ODImg/1661781900869.png)

通过PE文件可知,第一个节(`name`是`.text`)的`SizeOfRawData` = `0001A000`,第二个节(`name`是`.rdata`)的`SizeOfRawData` = `0001B000`

等同于第一个节表的可用内存地址范围是**第一个节的起始地址~第二个节的起始地址**  =>`0001B000`-`0001A000 =1000`

#### 3.我们将代码写入到第一个节表中

通过计算第一个节表的数据范围,我们找到看到第一个节表后面的部分还存在许多 未使用的地址 

![1661782269739](../img/ODImg/1661782269739.png)

我们就可以把我们需要执行的代码写到这一块. 

因为写到这一块有一个好处,这一块节表本来就输入代码区.写在代码区默认是**可执行**的(是否可执行,要看每个节中有一个`Characteristics`属性)



### 5.写入代码

我们知道messageBox需要参数(见3.2),所以我们第一个步骤是把4个参数压入栈中,对应硬编码为:

```
6A 00 6A 00 6A 00 6A 00 
```



![1661782942431](../img/ODImg/1661782942431.png)

​																					注意这个图应该是4个6A ,图中只写了3个



随后我们要调用硬编码对应的messagebox函数:

通过第2节的公式,以及messagebox对应的硬编码地址.套公式可知:

```
X = messagebox对应的硬编码地址 - ( imagebase+ E8+ 5 )
X = 77D507EA - (400000 + E8(0x0001a738h) + 5 )
X = 77D507EA - （400000+ E9的地址（0001a73dh））
X = 77D507EA - 0x41A73D
X = 779360AF
```

![1661783493452](../img/ODImg/1661783493452.png)

得到结果为`779360AF` (

注意1：小端存储[大端存储与小端存储理解 - wood2012 - 博客园 (cnblogs.com)](https://www.cnblogs.com/wood2012/p/8540169.html#:~:text=2).小端存储：,的逻辑方法一致。

注意2：截图中结果有误

)



E9 对应`JMP`硬编码:

现在问题是：我们已知真正的入口点`183D7`和当前的地址（`E9的地址`），此时还不确定的是 `JMP`到`OEP`的硬编码。

通过网上教程[ E9指令地址计算方法](https://blog.csdn.net/paradox_1_0/article/details/101272426),套用公式:



```
X = oep入口地址(imagebase+入口地址) - (E9 + 5)
X = 400000+183D7(不知道怎么来的看第1节) - (imagebase + E9 +5)
X = 400000+183D7 - ( 400000 + 1a742)
```

![1661783655631](../img/ODImg/1661783655631.png)

修改后的结果



### 6,修改OEP

我们从PE里面可知入口点是183D7 ,搜索字符串(ctrl+f) `D7 83 01`

![1661783857788](../img/ODImg/1661783857788.png)



改成`1a730`



### 7.运行效果

#### 1.先弹出消息框

![1661784197832](../img/ODImg/1661784197832.png)





#### 2.运行起飞鸽传书



### 8.总结

1. 通过`ODDebug`找到`MessageBoxA`对应的硬编码 (`77D507EA`)
2. 通过模拟程序调用`MessageBoxA` 获得参数的硬编码(`6A 00 6A 00 6A 00 6A 00`)
3. 通过`PETool 1.0.0.5.exe`工具找到节表，找到节表中拥有可读可写可执行(`Characteristics`)的节表(`.text`节表)
   1. 找到`.text`节表对应的`SizeOfRawData`属性对应的地址(`0001A000     `)
4. 通过`UlrEdit`软件定位`0001A000     `(`ctrl+g`)
   1. 在空白区域加入4个0作为`MessageBox`入参（对应硬编码为：`6A 00 6A 00 6A 00 6A 00`）
   2. 通过`call`硬编码计算公式 `真实的地址= X(硬编码) - E8的地址下一行  `填写`E8 硬编码后面的参数`  =》 `E8 AD 60 93 77`
   3. 通过`jmp`硬编码计算公式 `X(硬编码)  = 真实的地址 -  E9的地址下一行 ` =>  `E9 9A DC FF FF`
   4. 修改入口点（已知入口点`0x00400000 + 0x000183D7`）
      1. 使用`ctrl+f`搜索字符串`D783` ，找到地址`00000110h`
      2. 将地址`00000110h`内容修改为 4.1中空白区域的首地址（`0001a730h`）

