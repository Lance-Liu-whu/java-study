## 思路:

1.每个程序都有入口点(OEP),首先要找到OEP ,让原来执行OEP的第一条语句改为执行我们自定义的代码.

在执行完自定义代码后再继续执行OEP的代码.等同于在OEP前面先调用我们的代码



## 操作:

### 1.找到入口点(OEP) 

![1661780618817](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661780618817.png)

​		从图上可知, 偏移是ImageBase字段=`400000 `,入口点地址为`183D7` 。所以加上偏移的地址为`4183d7`

### 2.研究call, jmp指令硬编码

![1661780836929](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661780836929.png)

因为我们知道要实现先调用我们的代码. 要用到`call`指令.

调用完成后.要跳到OEP的地址,还需要用到`JMP`指令.

我们先看`call`指令硬编码.

通过红色方框可知 ,当前的地址是 `0x010d140E` ,最右边的注释是调用函数`function(10D119A)`,真实的硬编码是

`E8 87 FD FF FF`

其实调用函数`function(10D119A)`与当前的地址 `0x010d140E`和硬编码的关系是:

```
公式1:
真实的地址=E8的地址下一行(绿色方框) + X(硬编码)
```

如果我们要知道 `X(硬编码)的值`,可以将等式转换一下:

```
公式2:
X(硬编码)=真实的地址 - E8的地址下一行(绿色方框)  
```

同时:

红色方框`0x010d140E`与绿色方框`0x010d1413`之间的关系是

**绿色方框的地址 =  红色方框的地址+硬编码对应的字节数 =`0x010d140E` + `5` **

即公式2变形:

```
X(硬编码)=真实的地址 - ( E8的地址+5 )
```



### 3.找到MessageBoxA硬编码

#### 1.使用OD 下一个 bp MessageBoxA的断点

![1661776227580](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661776227580.png)

此时在我的机器上调用`MessageBox`的硬编码为`0x77D507EA`

#### 2.在正向代码中查看调用MessageBox参数

```c++
#include "stdafx.h"
#include <windows.h> 

void function () {
	MessageBox(0,0,0,0);
}


int _tmain(int argc, _TCHAR* argv[])
{
	function();
	return 0;
}


```

​																	正向代码





```
00D713C0 6A 00                push        0  
00D713C2 6A 00                push        0  
00D713C4 6A 00                push        0  
00D713C6 6A 00                push        0  
00D713C8 FF 15 38 83 D7 00    call        dword ptr [__imp__MessageBoxW@16 (0D78338h)]  
```

​																		汇编代码



通过汇编代码可知,参数的4个参数0,都是以硬编码`6A 00`传入的





### 4.找到飞鸽传书代码区

#### 1.使用ultraEdit打开飞鸽传书

#### 2.查看PE

![1661781900869](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661781900869.png)

通过PE文件可知,`SizeOfRawData` = `0001A000`

每次偏移`1000`(我这里理解为每一个节的长度是1000)

等同于第一个节表的可用内存地址范围是`0001A000`~`0001A000 + 1000(0001B000)`

#### 3.我们将代码写入到第一个节表中

通过计算第一个节表的数据范围,我们找到看到第一个节表后面的部分还存在许多 未使用的地址 

![1661782269739](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661782269739.png)

我们就可以把我们需要执行的代码写到这一块. 

因为写到这一块有一个好处,这一块节表本来就输入代码区.写在代码区默认是**可执行**的



### 5.写入代码

我们知道messageBox需要参数(见3.2),所以我们第一个步骤是把4个参数压入栈中,对应硬编码为:

```
6A 00 6A 00 6A 00 6A 00 
```



![1661782942431](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661782942431.png)

​																					注意这个图应该是4个6A ,图中只写了3个



随后我们要调用硬编码对应的messagebox函数:

通过第2节的公式,以及messagebox对应的硬编码地址.套公式可知:

```
X = messagebox对应的硬编码地址 - ( imagebase+ E8+ 5 )
X = 77D507EA - (400000 + E8 + 5 )
X = 779360AF
```

![1661783493452](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661783493452.png)

得到结果为`779360AD` (注意小端存储)



E9 应该JMP到OEP去:

套用公式:



```
X = oep入口地址(imagebase+入口地址) - (E9 + 5)
X = 400000+183D7(不知道怎么来的看第1节) - (imagebase + E9 +5)
X = 400000+183D7 - ( 400000 + 1a742)
```

![1661783655631](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661783655631.png)

修改后的结果



### 6,修改OEP

我们从PE里面可知入口点是183D7 ,搜索字符串(ctrl+f) `D7 83 01`

![1661783857788](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661783857788.png)



改成`1a730`



### 7.运行效果

#### 1.先弹出消息框

![1661784197832](https://github.com/q920447939/java-study/tree/master/img/ODImg/1661784197832.png)





#### 2.运行起飞鸽传书



