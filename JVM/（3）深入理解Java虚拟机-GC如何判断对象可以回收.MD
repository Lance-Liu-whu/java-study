# 深入理解Java虚拟机-GC如何判断对象可以回收

​	当我们知道`Java`语言拥有`GC`的能力后，那么，它是如何判断一个`对象`可以进行回收了的呢？

​	当我们需要自己设计一种`GC`回收策略时，该如何设计呢？

### 古老版本-引用计数法

​	如果这个对象被另外一个对象引用。那么这个对象在某个位置进行计数`+1`操作，没有引用了就进行`-1`操作。当对象的这个位置计数值为`0`时，那么可以认为这个对象可以被回收了。

​	但是这种方式不能处理一个问题。当循环引用时候导致两个对象均无法回收

### 升级版本-引用可达性分析

​	通过类似于二叉树的结构，`GC ROOT`做为根节点，寻找子节点的引用。	

​	什么是`GC ROOT` ？ 

```
在Java技术体系里面，固定可作为GC Roots的对象包括以下几种：
·在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的
参数、局部变量、临时变量等。
·在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。
·在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
·在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
·Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
·所有被同步锁（synchronized关键字）持有的对象。
·反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等
```

![image-20230131154225864.png](https://s2.loli.net/2023/02/02/uF2sxTftCIXe9RQ.png)

​		



#### 	问题与思考：

​		当那些固定的`GC ROOT对象产生时，默认就会与GC ROOT 根节点做为绑定？`



### 回收策略

​	还需要考虑一个场景，如果我们需要在内存还满足时，那么我们希望`某些对象`能够在`堆`上进行保留。如果内存不够时或者需要回收更多的内存时，在不影响业务的场景下可以进行回收。

​	那么对象的强弱关系就产生了。

##### 强引用（Strongly Re-ference）

​	只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。

##### 软引用（Soft Reference）

​	只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。

##### 弱引用（Weak Reference）

​	当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象

##### 虚引用（Phantom Reference）

​	一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚
引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。



### 总结：

​	了解到`GC`的回收策略，以及对象产生的`强弱关系`对`GC`的影响
