# 深入理解Java虚拟机

## Java虚拟机运行时数据区

![image-20230129092520794.png](https://s2.loli.net/2023/02/02/MT8kFsLKtgvplEm.png)
### 程序计数器

​	程序计数器（Program Counter Register）是一块较小的内存空间，它可以看作是当前线程所执行的
字节码的行号指示器。在Java虚拟机的概念模型里 [1] ，字节码解释器工作时就是通过改变这个计数器
的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处
理、线程恢复等基础功能都需要依赖这个计数器来完成。
​	由于Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一
个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因
此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程
之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。
​	如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地
址；如果正在执行的是本地（Native）方法，这个计数器值则应为空（Undefined）。此内存区域是唯
一一个在《Java虚拟机规范》中没有规定任何OutOfMemoryError情况的区域。

```
[1] “概念模型”这个词会经常被提及，它代表了所有虚拟机的统一外观，但各款具体的Java虚拟机并不
一定要完全照着概念模型的定义来进行设计，可能会通过一些更高效率的等价方式去实现它。
```

​	总结：在多线程情况下，处理器（CPU）通过调度策略让多个线程`"同时"`执行，为了记住每个线程在CPU调度切换之前运行到哪一行字节码，所以需要程序计数器来记录行数。

### Java虚拟机栈

​	与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stack）也是线程私有的，它的生命周期
与线程相同。虚拟机栈描述的是Java方法执行的线程内存模型：每个方法被执行的时候，Java虚拟机都
会同步创建一个栈帧 [1] （Stack Frame）用于存储局部变量表、操作数栈、动态连接、方法出口等信
息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
​	经常有人把Java内存区域笼统地划分为堆内存（Heap）和栈内存（Stack），这种划分方式直接继
承自传统的C、C++程序的内存布局结构，在Java语言里就显得有些粗糙了，实际的内存区域划分要比
这更复杂。不过这种划分方式的流行也间接说明了程序员最关注的、与对象内存分配关系最密切的区
域是“堆”和“栈”两块。其中，“堆”在稍后笔者会专门讲述，而“栈”通常就是指这里讲的虚拟机栈，或
者更多的情况下只是指虚拟机栈中局部变量表部分。
​	局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、
float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始
地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress
类型（指向了一条字节码指令的地址）。
​	这些数据类型在局部变量表中的存储空间以局部变量槽（Slot）来表示，其中64位长度的long和
double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编
译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定
的，在方法运行期间不会改变局部变量表的大小。请读者注意，这里说的“大小”是指变量槽的数量，
虚拟机真正使用多大的内存空间（譬如按照1个变量槽占用32个比特、64个比特，或者更多）来实现一
个变量槽，这是完全由具体的虚拟机实现自行决定的事情。
​	在《Java虚拟机规范》中，对这个内存区域规定了两类异常状况：如果线程请求的栈深度大于虚
拟机所允许的深度，将抛出StackOverflowError异常；如果Java虚拟机栈容量可以动态扩展 [2] ，当栈扩
展时无法申请到足够的内存会抛出OutOfMemoryError异常。

​	总结：

​		调用方法时 => Java虚拟机栈创建一个栈（数据结构，先进后出）帧

​	    执行方法过程中 => 存储运行过程中的变量信息（比如运行到放到的第XX行，某一个值已经变成了yy了。）

​        执行方法完成 => 出栈

### 本地方法栈

​	本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别只是虚拟机
栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的本地（Native）
方法服务。

​	总结：虚拟机栈为Java语言服务（保存调用方法的信息），本地方法栈为其他语言服务（C++,C）

### Java堆

​	总结：**所有线程共有**，Java堆自己设置初始化大小等参数。原HotSpot虚拟机将对分为`新生代、老年代`。这只是逻辑上的区分，只是为了让GC更好的回收内存

### 方法区

​	方法区（Method Area）与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载
的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。虽然《Java虚拟机规范》中把
方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”（Non-Heap），目的是与Java堆区
分开来。

​	总结：**所有线程共有**，存储常量、静态变量等信息。虚拟机也会回收这部分内容。只是条件比较苛刻（可能主要是做类的卸载操作）

也是逻辑上的区分。其实还在堆上

### 运行时常量池

​	总结：方法区的一部分，保存类的一些方法，接口，描述信息。（推测，既然是方法区的一部分，方法区又属于堆，那么这部分肯定也是**线程共有**，同时也会被`-Xmx`等内存分配参数限制内存大小，有可能会抛出内存溢出）



## 总结

![image-20230129153626912.png](https://s2.loli.net/2023/02/02/b6uF5WarxqUywAT.png)
