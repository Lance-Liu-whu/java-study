# 深入理解Java虚拟机-GC的收集算法概念



### 目前收集算法简要说明

#### 最古老版本-> 串行执行

- 优点  简单
- 缺点 回收对象时，需要暂停用户线程

#### 标记清除算法
![image-20230202113328423.png](https://s2.loli.net/2023/02/08/Nis5ZeyUlQ1gLon.png)
- 优点  
- 缺点 
  - 会造成内存碎片（如果要存大对象的话，往往需要连续的内存空间，因为内存不连贯了，导致无法存大对象。有可能又会触发一次GC或者Full GC ?）
#### 标记复制算法
![image-20230202113649984.png](https://s2.loli.net/2023/02/08/MQXwFT1O6f4i5a7.png)
将内存分为多份，先将对象存到一个内存区域中，如果要进行内存回收时，先把标记不需要清理的对象放到另外一块没有使用的内存中
- 优点  解决了内存碎片的问题
- 缺点  会浪费一份内存，也无法解决极端情况大对象超过分配的内存区域（内存被分为多份，假设总内存是10M，分为2份，那么如果要存一个6M的对象结果如何？）
#### 标记整理算法

![image-20230202114051168.png](https://s2.loli.net/2023/02/08/6liH4LnyTcCAjzY.png)
在标记清除算法的基础上，处理内存碎片的问题
​	

### HotSpot虚拟机实现

1. `GC ROOT`根节点开始扫描对象(`Stop the world`)

2. 让代码运行到安全点（书上讲解的例子的循环，跳转等指令相对会`耗时`，在这些地方设置安全点；同时，有些线程处于`Block`或者`Sleep`状态会认为处于安全区域）

   1. 方式
      1. 轮训 =》 没有虚拟机用这种方式
      2. 通过汇编指令`test` =》 简单高效

3. 通过`记忆集`解决对象跨代引用问题（`新生代引用老年代、老年代引用新生代`）

4. 通过`写屏障`处理`记忆集`变脏问题（对象被赋值？） =》 通过类似于在`AOP`在对象被赋值前执行操作和在执行后执行操作

5. 并发可达性分析 =》 引入三色标记

   1. 白色：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是
      白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。

   2. 黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代
      表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对
      象不可能直接（不经过灰色对象）指向某个白色对象。

   3. 灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

      ![image-20230202134427030.png](https://s2.loli.net/2023/02/08/j37RuNlrtngKkLZ.png)



简而言之：通过`GC ROOT`首次进行并发标记 ，如果一次顺利就可以进行回收；假如在并发标记过程中用户线程使得`GC ROOT`引用链发生改变，那么就将这个改变的点（黑色）改为灰色。
