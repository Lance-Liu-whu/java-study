**三次握手、四次挥手的常见面试题**
TCP连接建立的三次握手及拆除过程的四次挥手的面试问题是技术
面试过程中出现频率很高的重点和难点问题，常见问题大致如下：

问题（1）：为什么关闭连接时需要四次挥手，而建立连接却只要
三次握手？
关闭连接时，被动断开方在收到对方的FIN结束请求报文时很可能
没有发送完业务数据，并不能立即关闭连接，被动方只能先回复一个
ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等
到我所有的业务报文都发送完了，我才能真正结束，在结束之前，我
会发给你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文
需要拆成两步，故总共需要四次挥手。

在建立连接场景中，Server的应答可以稍微简单一些。当Server
收到Client的SYN连接请求报文后，其中ACK报文表示对请求报文的应
答，SYN报文表示服务端的连接也已经同步开启了，而ACK报文和SYN报
文之间不会有其他报文需要发送，故而可以合二为一，可以直接发送
一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。





问题（2）：为什么连接建立的时候是三次握手，可以改成两次握
手吗？
三次握手完成两个重要的功能：一是双方都做好发送数据的准备
工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的
协商，双方的SN序列号在握手过程中被发送和确认。
如果把三次握手改成两次握手，可能发生死锁。两次握手的话，
缺失了Client的二次确认ACK帧，假想的TCP建立连接时的二次挥手可
以

![image-20230522201601450](F:\liming\work_space\my_work_space\java-study\img\tcp\image-20230522201601450.png)

在假想的TCP建立连接时的二次握手过程中，Client给Server发送
一个SYN请求帧，Server收到后发送确认应答SYN+ACK帧。按照两次握
手的协定，Server认为连接已经成功地建立，可以开始发送数据帧。
在这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有
收到，Client将不知道Server是否已准备好，也不知道Server的SN序
列号，Client认为连接还未建立成功，将忽略Server发来的任何数据
分组，会一直等待Server的SYN+ACK确认应答帧。Server在发出的数据
帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的
数据帧。这样就形成了死锁。





问题（3）：为什么主动断开方在TIME-WAIT状态必须等待2MSL？

原因之一：主动断开方等待2MSL的时间是为了确保两端都能最终
关闭。假设网络是不可靠的，被动断开方发送FIN+ACK报文后，其主动
方的ACK响应报文有可能丢失，这时的被动断开方处于LAST-ACK状态，
由于收不到ACK确认被动方一直不能正常地进入CLOSED状态。在这种场
景下，被动断开方会超时重传FIN+ACK断开响应报文，如果主动断开方
在2MSL时间内收到这个重传的FIN+ACK报文，就会重传一次ACK报文，
然后再一次重新启动2MSL计时等待，这样就能确保被动断开方能收到
ACK报文，从而能确保被动方顺利进入CLOSED状态。只有这样，双方才
都能够确保关闭。反过来说，如果主动断开方在发送完ACK响应报文后
不是进入TIME_WAIT状态去等待2MSL时间，而是立即释放连接，则将无
法收到被动方重传的FIN+ACK报文，所以不会再发送一次ACK确认报
文，此时处于LAST-ACK状态的被动断开方无法正常进入CLOSED状态。
原因之二：防止“旧连接已失效的数据报文”出现在新连接中。
主动断开方在发送完最后一个ACK报文后再经过2MSL才能最终关闭和释
放端口。这就意味着，相同端口的新TCP新连接需要在2MSL的时间之后

才能够正常建立。2MSL这段时间内，旧连接所产生的所有数据报文都
已经从网络中消失了，从而确保下一个新的连接中不会出现这种旧连
接请求报文。



问题（4）：如果已经建立了连接，但是Client端突然出现故障了
怎么办？



TCP还设有一个保活计时器，Client如果出现故障，Server不能一
直等下去，这样会浪费系统资源。每收到一次Client的数据帧后，
Server的保活计时器都会复位。计时器的超时时间通常设置为2小时，
若2小时还没有收到Client的任何数据帧，Server就会发送一个探测报
文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没有反
应，Server就认为Client出了故障，接着关闭连接。如果觉得保活计
时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。
